[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "x + 1"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "LaughingRook",
    "section": "",
    "text": "Order By\n       Default\n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Title\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\nDate\n\n\nTitle\n\n\nCategories\n\n\n\n\n\n\nAug 27, 2022\n\n\nAdvent of Code 2015, Day 2\n\n\nAdventOfCode\n\n\n\n\nAug 25, 2022\n\n\nTravelling Salesperson Problem (Brute-force Search)\n\n\nAlgorithm,Graph\n\n\n\n\nAug 22, 2022\n\n\nStratified Analyses\n\n\nM249,Statistics\n\n\n\n\nAug 20, 2022\n\n\nAdvent of Code 2015, Day 1\n\n\nAdventOfCode\n\n\n\n\nAug 18, 2022\n\n\nInitialising an Undirected Graph in NetworkX\n\n\nGraph\n\n\n\n\nAug 15, 2022\n\n\nCohort and Case-Control Studies\n\n\nM249,Statistics\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/2022-08-15-cohort_case_control_studies.html",
    "href": "posts/2022-08-15-cohort_case_control_studies.html",
    "title": "Cohort and Case-Control Studies",
    "section": "",
    "text": "Perform an epidemiological study on the results of a cohort study analysing the possible association between compulsory redundancies and incidents of serious self-inflicted injury (SSI) (Keefe, V., et al (2002)). The exposure is being made compulsorily redundant, and the disease is incidents of serious self-inflicted injury.\nThe study results were as follows.\n\n\n\n\nSSI (+)\nno SSI (-)\n\n\n\n\nmade redundant (+)\n14\n1931\n\n\nnot made redundant (-)\n4\n1763\n\n\n\nThe results were initialised as a NumPy array, and the analysis was undertaken using (mainly) StatsModels’ Table2x21 class and SciPy. Measures of association2 were calculated, including confidence interval estimates. A chi-squared test of no association was used to test the strength of evidence of an association. We rounded-off the analysis by performing Fisher’s exact test.3 4\nNote, some of the results were outputted as Pandas Series, rather than using the default return type. This was done done to provide a more standardised results output.\nThese topics are covered by M249 Book 1, Part 1.\nWe used kernel=lr_stats."
  },
  {
    "objectID": "posts/2022-08-15-cohort_case_control_studies.html#dependencies",
    "href": "posts/2022-08-15-cohort_case_control_studies.html#dependencies",
    "title": "Cohort and Case-Control Studies",
    "section": "Dependencies",
    "text": "Dependencies\n\nimport numpy as np\nimport pandas as pd\nfrom scipy import stats as st\nfrom statsmodels import api as sm"
  },
  {
    "objectID": "posts/2022-08-15-cohort_case_control_studies.html#constants",
    "href": "posts/2022-08-15-cohort_case_control_studies.html#constants",
    "title": "Cohort and Case-Control Studies",
    "section": "Constants",
    "text": "Constants\nThese are the results from the study.\n\nOBS = np.array([[14, 1931], [4, 1763]])"
  },
  {
    "objectID": "posts/2022-08-15-cohort_case_control_studies.html#main",
    "href": "posts/2022-08-15-cohort_case_control_studies.html#main",
    "title": "Cohort and Case-Control Studies",
    "section": "Main",
    "text": "Main\n\nInitialise the contingency table\n\nctable = sm.stats.Table2x2(OBS)\nprint(ctable)\n\nA 2x2 contingency table with counts:\n[[  14. 1931.]\n [   4. 1763.]]\n\n\n\n\nMeasures of association\nReturn point and interval estimates of the odds ratio.\n\npd.Series(\n    data=[ctable.oddsratio,\n          ctable.oddsratio_confint()[0],\n          ctable.oddsratio_confint()[1]],\n    index=['point', 'lcb', 'ucb'],\n    name='odds ratio'\n)\n\npoint    3.195495\nlcb      1.049877\nucb      9.726081\nName: odds ratio, dtype: float64\n\n\nReturn point and interval estimates for the relative risk.\n\npd.Series(\n    data=[ctable.riskratio,\n          ctable.riskratio_confint()[0],\n          ctable.riskratio_confint()[1]],\n    index=['point', 'lcb', 'ucb'],\n    name='relative risk'\n)\n\npoint    3.179692\nlcb      1.048602\nucb      9.641829\nName: relative risk, dtype: float64\n\n\n\n\nChi-squared test for no association\nReturn the expected frequencies under the null hypothesis of no association.\n\nctable.fittedvalues\n\narray([[   9.43157328, 1935.56842672],\n       [   8.56842672, 1758.43157328]])\n\n\nReturn the differences between the observed and expected frequencies.\n\nOBS - ctable.fittedvalues\n\narray([[ 4.56842672, -4.56842672],\n       [-4.56842672,  4.56842672]])\n\n\nReturn the contributions to the chi-squared test statistic.\n\nctable.chi2_contribs\n\narray([[2.21283577, 0.01078263],\n       [2.43574736, 0.01186883]])\n\n\nReturn the results of the chi-squared test.\nWe pass the argument dtype=object, so the Series can handle both float and int data types.\n\nres = ctable.test_nominal_association()\npd.Series(\n    data=[res.statistic, res.pvalue, int(res.df)],\n    index=['statistc', 'pvalue', 'df'],\n    name='chi-squared test',\n    dtype=object\n)\n\nstatistc    4.671235\npvalue      0.030672\ndf                 1\nName: chi-squared test, dtype: object\n\n\n\n\nFisher’s exact test\n\n_, pvalue = st.fisher_exact(ctable.table)\npd.Series(\n    data=[pvalue],\n    index=['pvalue'],\n    name='fisher''s exact'\n)\n\npvalue    0.033877\nName: fishers exact, dtype: float64"
  },
  {
    "objectID": "posts/2022-08-15-cohort_case_control_studies.html#references",
    "href": "posts/2022-08-15-cohort_case_control_studies.html#references",
    "title": "Cohort and Case-Control Studies",
    "section": "References",
    "text": "References\nVera Keefe, Papaarangi Reid, Clint Ormsby, Bridget Robson, Gordon Purdie, Joanne Baxter, Ngäti Kahungunu Iwi Incorporated, Serious health events following involuntary job loss in New Zealand meat processing workers, International Journal of Epidemiology, Volume 31, Issue 6, December 2002, Pages 1155–1161, https://doi.org/10.1093/ije/31.6.1155\n\n%load_ext watermark\n%watermark --iv\n\nnumpy      : 1.23.2\nscipy      : 1.9.0\nstatsmodels: 0.13.2\nsys        : 3.10.6 (tags/v3.10.6:9c7b4bd, Aug  1 2022, 21:53:49) [MSC v.1932 64 bit (AMD64)]\npandas     : 1.4.3"
  },
  {
    "objectID": "posts/2022-08-18-initialise_undirected_graph_networkx.html",
    "href": "posts/2022-08-18-initialise_undirected_graph_networkx.html",
    "title": "Initialising an Undirected Graph in NetworkX",
    "section": "",
    "text": "Initialise and populate an undirected weighted graph using NetworkX.\nThe source data is a CSV file listing the road network in Europe as an edge list.1\nWe first imported the data into a Pandas DataFrame.2 Next, we exported the DataFrame as a collection of dictionaries.3 We initialised an empty graph,4 and populated it. We closed the notebook by showing how to access the nodes, neighbors, and edges of the graph.\nWhilst we could populate the graph during initialisation, we found it added unneeded complexity.\nThe |edges| ≠ |edge list| because NetworkX’s Graph class does not permit parallel edges between two nodes.5"
  },
  {
    "objectID": "posts/2022-08-18-initialise_undirected_graph_networkx.html#dependencies",
    "href": "posts/2022-08-18-initialise_undirected_graph_networkx.html#dependencies",
    "title": "Initialising an Undirected Graph in NetworkX",
    "section": "Dependencies",
    "text": "Dependencies\n\nfrom dataclasses import dataclass\nimport pandas as pd\nimport networkx as nx\n\n\nClasses\n\n@dataclass(frozen=True)\nclass PandasERoad:\n    \"\"\"A dataclass to help the conversion of the raod network data as a\n    graph.\n\n    Stores the remote url and maps the column titles to common graph\n    terminology\n    \"\"\"\n\n    url: str = ('https://raw.githubusercontent.com/ljk233'\n                + '/laughingrook-datasets/main/graphs/eroads_edge_list.csv')\n    u: str = 'origin_reference_place'\n    v: str = 'destination_reference_place'\n    uco: str = 'origin_country_code'\n    vco: str = 'destination_country_code'\n    w: str = 'distance'\n    rn: str = 'road_number'\n    wc: str = 'watercrossing'"
  },
  {
    "objectID": "posts/2022-08-18-initialise_undirected_graph_networkx.html#functions",
    "href": "posts/2022-08-18-initialise_undirected_graph_networkx.html#functions",
    "title": "Initialising an Undirected Graph in NetworkX",
    "section": "Functions",
    "text": "Functions\n\ndef edge_to_tuple(edge: dict, er: PandasERoad) -> tuple:\n    return (\n        edge[er.u],\n        edge[er.v],\n        {'weight': edge[er.w], er.rn: edge[er.rn], er.wc: edge[er.wc]}\n    )"
  },
  {
    "objectID": "posts/2022-08-18-initialise_undirected_graph_networkx.html#main",
    "href": "posts/2022-08-18-initialise_undirected_graph_networkx.html#main",
    "title": "Initialising an Undirected Graph in NetworkX",
    "section": "Main",
    "text": "Main\n\ner = PandasERoad()\n\n\nImport the data\n\neroads = pd.read_csv(er.url)\neroads.info()\n\n<class 'pandas.core.frame.DataFrame'>\nRangeIndex: 1250 entries, 0 to 1249\nData columns (total 7 columns):\n #   Column                       Non-Null Count  Dtype \n---  ------                       --------------  ----- \n 0   road_number                  1250 non-null   object\n 1   origin_country_code          1250 non-null   object\n 2   origin_reference_place       1250 non-null   object\n 3   destination_country_code     1250 non-null   object\n 4   destination_reference_place  1250 non-null   object\n 5   distance                     1250 non-null   int64 \n 6   watercrossing                1250 non-null   bool  \ndtypes: bool(1), int64(1), object(5)\nmemory usage: 59.9+ KB\n\n\n\n\nExport data to a dictionary\nEach entry in the list is a dictionary representing a single row, where the keys are the column titles.\n\nedges = eroads.to_dict(orient='records')\nedges[0]\n\n{'road_number': 'E01',\n 'origin_country_code': 'GB',\n 'origin_reference_place': 'Larne',\n 'destination_country_code': 'GB',\n 'destination_reference_place': 'Belfast',\n 'distance': 36,\n 'watercrossing': False}\n\n\n\n\nInitalise and populate the graph\n\ng = nx.Graph()\n\nAdds the nodes. We perform it on both the source and destination nodes in the edge list to ensure we populate all the cities, given there’s a chance that a city does not appear as a source city in the data.\n\ng.add_nodes_from((e[er.u], {'country': e[er.uco]}) for e in edges)\ng.add_nodes_from((e[er.v], {'country': e[er.vco]}) for e in edges)\n\nAdd the edges. Given this is an undirected graph, there is no need to add the reverse edges V → U.\nExample of output from edge_to_tuple\n\nedge_to_tuple(edges[0], er)\n\n('Larne',\n 'Belfast',\n {'weight': 36, 'road_number': 'E01', 'watercrossing': False})\n\n\nPopulate the edges.\n\ng.add_edges_from(edge_to_tuple(edge, er) for edge in edges)\n\n\n\nInspect the graph\nGet a description of the graph.\n\nprint(g)\n\nGraph with 894 nodes and 1198 edges\n\n\nGet a selection of the nodes.\n\n[n for n in g][:5]\n\n['Larne', 'Belfast', 'Dublin', 'Wexford', 'Rosslare']\n\n\nOutput a more descriptive list of nodes by calling the nodes() method.\n\n[n for n in g.nodes(data=True)][:5]\n\n[('Larne', {'country': 'GB'}),\n ('Belfast', {'country': 'GB'}),\n ('Dublin', {'country': 'IRL'}),\n ('Wexford', {'country': 'IRL'}),\n ('Rosslare', {'country': 'IRL'})]\n\n\nView the neighbours of the Roma node.\n\n[neighbor for neighbor in g['Roma']]\n\n['Arezzo', 'Grosseto', 'Pescara', 'San Cesareo']\n\n\nWe can get a more descriptive output of a node’s neighbours by not using list comprehension.\n\ng['Roma']\n\nAtlasView({'Arezzo': {'weight': 219, 'road_number': 'E35', 'watercrossing': False}, 'Grosseto': {'weight': 182, 'road_number': 'E80', 'watercrossing': False}, 'Pescara': {'weight': 209, 'road_number': 'E80', 'watercrossing': False}, 'San Cesareo': {'weight': 36, 'road_number': 'E821', 'watercrossing': False}})\n\n\nFinally, we can simply output the edges of the Roma node.\n\n[e for e in g.edges('Roma', data=True)]\n\n[('Roma',\n  'Arezzo',\n  {'weight': 219, 'road_number': 'E35', 'watercrossing': False}),\n ('Roma',\n  'Grosseto',\n  {'weight': 182, 'road_number': 'E80', 'watercrossing': False}),\n ('Roma',\n  'Pescara',\n  {'weight': 209, 'road_number': 'E80', 'watercrossing': False}),\n ('Roma',\n  'San Cesareo',\n  {'weight': 36, 'road_number': 'E821', 'watercrossing': False})]\n\n\n\n%load_ext watermark\n%watermark --iversions\n\nnetworkx: 2.8.6\nsys     : 3.10.6 (tags/v3.10.6:9c7b4bd, Aug  1 2022, 21:53:49) [MSC v.1932 64 bit (AMD64)]\npandas  : 1.4.3"
  },
  {
    "objectID": "posts/2022-08-20-advent_of_code_2015_day1.html",
    "href": "posts/2022-08-20-advent_of_code_2015_day1.html",
    "title": "Advent of Code 2015, Day 1",
    "section": "",
    "text": "This is my solution to Advent of Code 2015, Day 1: Not Quite Lisp."
  },
  {
    "objectID": "posts/2022-08-20-advent_of_code_2015_day1.html#dependencies",
    "href": "posts/2022-08-20-advent_of_code_2015_day1.html#dependencies",
    "title": "Advent of Code 2015, Day 1",
    "section": "Dependencies",
    "text": "Dependencies\n\nfrom itertools import accumulate\nimport laughingrook as lr"
  },
  {
    "objectID": "posts/2022-08-20-advent_of_code_2015_day1.html#functions",
    "href": "posts/2022-08-20-advent_of_code_2015_day1.html#functions",
    "title": "Advent of Code 2015, Day 1",
    "section": "Functions",
    "text": "Functions\n\ndef find_first(x, A) -> int:\n    \"\"\"Find the first index i where A[i] = x.\n\n    Precondtions:\n    - x in A\n    - A is 1-dimensional\n    - A support iteration\n    \"\"\"\n    return next(i for i, a in enumerate(A) if a == x)"
  },
  {
    "objectID": "posts/2022-08-20-advent_of_code_2015_day1.html#main",
    "href": "posts/2022-08-20-advent_of_code_2015_day1.html#main",
    "title": "Advent of Code 2015, Day 1",
    "section": "Main",
    "text": "Main\n\nLoad the input\n\nline = lr.datasets.get_advent_input(2015, 1)\nprint(f\"line = '{line[:5]}'\")\n\nline = '()((('\n\n\n\n\nTransform the input\n\nm = {'(': 1, ')': -1}\ndirections = [m[bracket] for bracket in line]\nprint(f\"directions = {directions[:5]}\")\n\ndirections = [1, -1, 1, 1, 1]\n\n\n\n\nPart 1\n\nprint(f\"Solution = {sum(directions)}\")\n\nSolution = 138\n\n\n\n\nPart 2\n\nprint(f\"Solution = {find_first(-1, accumulate(directions)) + 1}\")\n\nSolution = 1771\n\n\n\n\nPerformance\n\nprint('Part 1 =')\n%timeit sum(directions)\nprint('Part 2 =')\n%timeit find_first(-1, accumulate(directions)) + 1\n\nPart 1 =\n62.5 µs ± 1.03 µs per loop (mean ± std. dev. of 7 runs, 10,000 loops each)\nPart 2 =\n73.6 µs ± 468 ns per loop (mean ± std. dev. of 7 runs, 10,000 loops each)"
  },
  {
    "objectID": "posts/2022-08-22-stratified_analyses.html",
    "href": "posts/2022-08-22-stratified_analyses.html",
    "title": "Stratified Analyses",
    "section": "",
    "text": "Perform a stratified analyses on the results of a stratified case-control study.\nData was taken from investigating the possible association between alcohol consumption and fatal car accidents in New York (J.R. McCarroll and W. Haddon Jr, 1962). The data was stratified by marital status, which was believed to be a possible confounder. The exposure was blood alcohol level of 100mg% or greater. Cases were drivers who were killed in car accidents for which they were considered to be responsible, and controls were selected drivers passing the locations where the accidents of the cases occurred, at the same time of day and on the same day of the week.\nThe results were as follows.\nStratum 1\n\n\n\nMarried\ncases (+)\ncontrols (-)\n\n\n\n\nexposed (+)\n4\n5\n\n\nnot exposed (-)\n5\n103\n\n\n\nStratum 2\n\n\n\nNot married\ncases (+)\ncontrols (-)\n\n\n\n\nexposed (+)\n10\n3\n\n\nnot exposed (-)\n5\n43\n\n\n\nThe results were initialised as two NumPy NDArrays, one for each stratum/level. The analysis was performed using two classes from StatsModels: StratifiedTable1 and Table2x2.2 The results were outputted to either a Pandas Series or DataFrame, depending on the dimensionality of the result. (This is optional, and done so to provide a standardised output.)\nThese topics are covered in M249, Book 1, Part 2."
  },
  {
    "objectID": "posts/2022-08-22-stratified_analyses.html#dependencies",
    "href": "posts/2022-08-22-stratified_analyses.html#dependencies",
    "title": "Stratified Analyses",
    "section": "Dependencies",
    "text": "Dependencies\n\nimport numpy as np\nimport pandas as pd\nfrom statsmodels import api as sm"
  },
  {
    "objectID": "posts/2022-08-22-stratified_analyses.html#constants",
    "href": "posts/2022-08-22-stratified_analyses.html#constants",
    "title": "Stratified Analyses",
    "section": "Constants",
    "text": "Constants\nThese are the results from the study.\n\nMARRIED = np.array([[4, 5], [5, 103]])\nNOT_MARRIED = np.array([[10, 3], [5, 43]])"
  },
  {
    "objectID": "posts/2022-08-22-stratified_analyses.html#main",
    "href": "posts/2022-08-22-stratified_analyses.html#main",
    "title": "Stratified Analyses",
    "section": "Main",
    "text": "Main\n\nInitialise the contingency tables\n\nctables = sm.stats.StratifiedTable([MARRIED, NOT_MARRIED])\nprint(ctables.table)\n\n[[[  4.  10.]\n  [  5.   3.]]\n\n [[  5.   5.]\n  [103.  43.]]]\n\n\n\n\nOdds ratios\nReturn point and interval estimates of the stratum-specific odds ratios.\n\nres = pd.DataFrame(index=['point', 'lcb', 'ucb'])\nfor level, arr in zip(['married', 'not married'], [MARRIED, NOT_MARRIED]):\n    ctable = sm.stats.Table2x2(arr)\n    res[level] = [ctable.oddsratio,\n                  ctable.oddsratio_confint()[0],\n                  ctable.oddsratio_confint()[1]]\nres.T\n\n\n\n\n\n  \n    \n      \n      point\n      lcb\n      ucb\n    \n  \n  \n    \n      married\n      16.480000\n      3.354211\n      80.969975\n    \n    \n      not married\n      28.666667\n      5.856619\n      140.316070\n    \n  \n\n\n\n\nReturn point and interval estimates of the crude odds ratio.\n\nctable = sm.stats.Table2x2(MARRIED + NOT_MARRIED)\npd.Series(\n    data=[ctable.oddsratio,\n          ctable.oddsratio_confint()[0],\n          ctable.oddsratio_confint()[1]],\n    index=['point', 'lcb', 'ucb'],\n    name='odds ratio'\n)\n\npoint    25.550000\nlcb       8.682174\nucb      75.188827\nName: odds ratio, dtype: float64\n\n\nReturn point and interval estimates of the adjusted (Mantel–Haenszel) odds ratio.\n\npd.Series(\n    data=[ctables.oddsratio_pooled,\n          ctables.oddsratio_pooled_confint()[0],\n          ctables.oddsratio_pooled_confint()[1]],\n    index=['point', 'lcb', 'ucb'],\n    name='Mantel-Haeszel odds ratio'\n)\n\npoint    23.000610\nlcb       7.465154\nucb      70.866332\nName: Mantel-Haeszel odds ratio, dtype: float64\n\n\n\n\nTest for no association\nThis is the Mantel–Haenszel test.\n\nres = ctables.test_null_odds(correction=True)\npd.Series(\n    data=[res.statistic.round(5), res.pvalue.round(5)],\n    index=['statistc', 'pvalue'],\n    name='test for no association',\n)\n\nstatistc    36.60431\npvalue       0.00000\nName: test for no association, dtype: float64\n\n\n\n\nTest for homogeneity\nThis is Tarone’s test.\n\nres = ctables.test_equal_odds(adjust=True)\npd.Series(\n    data=[res.statistic.round(5), res.pvalue.round(5)],\n    index=['statistc', 'pvalue'],\n    name='test for homogeneity'\n)\n\nstatistc    0.23557\npvalue      0.62742\nName: test for homogeneity, dtype: float64"
  },
  {
    "objectID": "posts/2022-08-22-stratified_analyses.html#references",
    "href": "posts/2022-08-22-stratified_analyses.html#references",
    "title": "Stratified Analyses",
    "section": "References",
    "text": "References\nMcCarroll, J.R. and Haddon Jr, W., 1962. A controlled study of fatal automobile accidents in New York City. Journal of chronic diseases, 15(8), pp.811-826.\n\n%load_ext watermark\n%watermark --iversions\n\npandas     : 1.4.3\nstatsmodels: 0.13.2\nnumpy      : 1.23.2\nsys        : 3.10.6 (tags/v3.10.6:9c7b4bd, Aug  1 2022, 21:53:49) [MSC v.1932 64 bit (AMD64)]"
  },
  {
    "objectID": "posts/2022-08-25-tsp_bruteforce.html",
    "href": "posts/2022-08-25-tsp_bruteforce.html",
    "title": "Travelling Salesperson Problem (Brute-force Search)",
    "section": "",
    "text": "A solution to the Travelling Salesperson Problem using a brute-force search.\nThe Travelling Salesperson Problem is defined as:\n\nGiven a set of cities and distances between every pair of cities, the [Travelling Salesperson] problem is to find the shortest possible route that visits every city exactly once and returns to the starting point.\nTraveling Salesman Problem (TSP) Implementation (GeeksForGeeks)\n\nIn this implementation, we generate permutations and check if the |path| < |min path|.\nWe use a complete undirected graph, with each edge being assigned a random weight (representing the distance).\nWhilst the function works, it is unusuable when |nodes(g)| ≥ 11, given P(11, 11) = 36720000 permutations to check!"
  },
  {
    "objectID": "posts/2022-08-25-tsp_bruteforce.html#dependencies",
    "href": "posts/2022-08-25-tsp_bruteforce.html#dependencies",
    "title": "Travelling Salesperson Problem (Brute-force Search)",
    "section": "Dependencies",
    "text": "Dependencies\n\nimport random as rand\nimport math\nimport itertools as it\nimport networkx as nx\n%load_ext watermark"
  },
  {
    "objectID": "posts/2022-08-25-tsp_bruteforce.html#function",
    "href": "posts/2022-08-25-tsp_bruteforce.html#function",
    "title": "Travelling Salesperson Problem (Brute-force Search)",
    "section": "Function",
    "text": "Function\n\ndef bruteforce_tsp(G: nx.Graph, start: object) -> float | int:\n    \"\"\"Return the shortest route that visits every city exactly once and\n    ends back at the start.\n\n    Solves the travelling salesperson with a brute-force search using\n    permutations.\n\n    Preconditions:\n    - G is a complete weighted graph\n    - start in G\n    - WG[u, v]['weight'] is the distance u -> v\n    \"\"\"\n    neighbours = set((node for node in G.nodes if node != start))\n    min_dist = math.inf\n    for path in it.permutations(neighbours):\n        u, dist = start, 0\n        for v in path:\n            dist += G.edges[u, v]['weight']\n            u = v\n        min_dist = min(min_dist, dist + G.edges[u, start]['weight'])\n\n    return min_dist"
  },
  {
    "objectID": "posts/2022-08-25-tsp_bruteforce.html#main",
    "href": "posts/2022-08-25-tsp_bruteforce.html#main",
    "title": "Travelling Salesperson Problem (Brute-force Search)",
    "section": "Main",
    "text": "Main\n\nInitialise the graph\nWe initialise a complete weighted undirected graph with 5 nodes.\n\ncg = nx.complete_graph(['origin', 'a', 'b', 'c', 'd'])\ng = nx.Graph((u, v, {'weight': rand.randint(1, 10)}) for u, v in cg.edges)\nprint(f\"g = {g}\")\n\ng = Graph with 5 nodes and 10 edges\n\n\n\n\nFind the shortest path from the origin\n\nprint(f\"Shortest path from the origin = {bruteforce_tsp(g, 'origin')}\")\n\nShortest path from the origin = 22\n\n\n\n\nPerformance\n\nfor n in [4, 6, 8, 10]:\n    print(f\"|nodes(g)| = {n}\")\n    cg = nx.complete_graph(n)\n    g = nx.Graph((u, v, {'weight': rand.randint(1, 10)}) for u, v in cg.edges)\n    %timeit bruteforce_tsp(g, 1)\n\n|nodes(g)| = 4\n8 µs ± 40.4 ns per loop (mean ± std. dev. of 7 runs, 100,000 loops each)\n|nodes(g)| = 6\n202 µs ± 532 ns per loop (mean ± std. dev. of 7 runs, 10,000 loops each)\n|nodes(g)| = 8\n10.9 ms ± 38.2 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)\n|nodes(g)| = 10\n960 ms ± 7.42 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)\n\n\n\nprint('kernel\\t: lr_compsci')\n%watermark --iversions\n\nkernel  : lr_compsci\nsys     : 3.10.6 (tags/v3.10.6:9c7b4bd, Aug  1 2022, 21:53:49) [MSC v.1932 64 bit (AMD64)]\nnetworkx: 2.8.6"
  },
  {
    "objectID": "posts/2022-08-27-advent_of_code_2015_day2.html",
    "href": "posts/2022-08-27-advent_of_code_2015_day2.html",
    "title": "Advent of Code 2015, Day 2",
    "section": "",
    "text": "This is my solution to Advent of Code 2015, Day 2: I Was Told There Would Be No Math."
  },
  {
    "objectID": "posts/2022-08-27-advent_of_code_2015_day2.html#dependencies",
    "href": "posts/2022-08-27-advent_of_code_2015_day2.html#dependencies",
    "title": "Advent of Code 2015, Day 2",
    "section": "Dependencies",
    "text": "Dependencies\n\nimport laughingrook as lr"
  },
  {
    "objectID": "posts/2022-08-27-advent_of_code_2015_day2.html#functions",
    "href": "posts/2022-08-27-advent_of_code_2015_day2.html#functions",
    "title": "Advent of Code 2015, Day 2",
    "section": "Functions",
    "text": "Functions\n\ndef paper_needed(length: int, width: int, height: int) -> int:\n    \"\"\"Return the wrapping paper needed for a present with dims (l, w, h).\n    \"\"\"\n    planes = [(length * width), (width * height), (height * length)]\n    return min(planes) + (2 * sum(planes))\n\n\ndef ribbon_needed(length: int, width: int, height: int) -> int:\n    \"\"\"Return the ribbon needed to cover a present with dims (l, w, h).\n    \"\"\"\n    bow = length * width * height\n    ribbon = 2 * sum(sorted([length, width, height])[:2])\n    return bow + ribbon"
  },
  {
    "objectID": "posts/2022-08-27-advent_of_code_2015_day2.html#main",
    "href": "posts/2022-08-27-advent_of_code_2015_day2.html#main",
    "title": "Advent of Code 2015, Day 2",
    "section": "Main",
    "text": "Main\n\nLoad the input\n\nlines = lr.datasets.get_advent_input(2015, 2)\nprint(f\"lines = {lines[:5]}\")\n\nfile was cached.\nlines = ['4x23x21', '22x29x19', '11x4x11', '8x10x5', '24x18x16']\n\n\n\n\nTransform the input\n\nllines = (line.split('x') for line in lines)\npdims = [[int(x) for x in lline] for lline in llines]\nprint(f\"pdims = {pdims[:5]}\")\n\npdims = [[4, 23, 21], [22, 29, 19], [11, 4, 11], [8, 10, 5], [24, 18, 16]]\n\n\n\n\nPart 1\n\nprint(f\"Solution = {sum(paper_needed(l, w, h) for (l, w, h) in pdims)}\")\n\nSolution = 1598415\n\n\n\n\nPart 2\n\nprint(f\"Solution = {sum(ribbon_needed(l, w, h) for (l, w, h) in pdims)}\")\n\nSolution = 3812909\n\n\n\n\nPerformance\n\nprint('Part 1 =')\n%timeit sum(paper_needed(l, w, h) for (l, w, h) in pdims)\nprint('Part 2 =')\n%timeit sum(ribbon_needed(l, w, h) for (l, w, h) in pdims)\n\nPart 1 =\n433 µs ± 2.7 µs per loop (mean ± std. dev. of 7 runs, 1,000 loops each)\nPart 2 =\n468 µs ± 2.19 µs per loop (mean ± std. dev. of 7 runs, 1,000 loops each)"
  }
]